.	\" %M%	%I%	(CARL)	%G%	%U%
.	\" NQ - numbered program
.de NQ
.sp
.ce
Program example \\*(SN
..
.	\" NS - numbered score
.de NS
.sp
.ce
Score example \\*(SN
..
.EQ
delim $$
.EN
.ds LH PLAYER 
.ds RH TUTORIAL
.ds CF 2nd DRAFT
.TL
TUTORIAL INTRODUCTION TO PLAYER
.AU
Gareth Loy
.AI
Computer Audio Research Laboratory
Center for Music Experiment and Related Research, Q-037
University of California, San Diego
La Jolla, California 92093
(619) 534-4383
ucbvax!sdcarl!dgl
.AB 
Player
is a music programming language implemented as
a set of extensions to the C programming
language.
.[
kernighan
programming language
.]
.LP
The principal motivations for its design are to provide 
parallel processing in a musical context,
symbolic and functional music data representation, combined with
the general-purpose programming facilities of the C language.
.LP
This tutorial is directed at those already familiar with C programming
and acquainted with the CARL sound-processing environment.
.[
startup kit
.]
.AE
.SH
Introduction
.LP
Player is a general purpose programming language for music built out of the
C programming language.  The environment provides easy access
to standard UNIX timesharing system conventions.  
This tutorial discusses its use to
write simple programs
that generate musical scores suitable as 
input to 
\fIcmusic\fP(1CARL).
.[
startup kit
.]
There are two implementations of Player at this time; one 
runs under the
.UX
timesharing system.
In this mode, Player is useful for expressing compositional algorithms,
but has no facility for live performance interaction.
The other implementation of Player is designed
to run standalone on a dedicated microcomputer
for realtime performance processing.  This tutorial only covers
the timesharing version.
.LP
The formal exposition of Player is made elsewhere.
.[
player extensions
.]
Additional documentation about the various actions and options of the
Player compiler and runtime library are available on-line as manual
pages.
.LP
The examples are in three parts: a discussion, an example
Player source program, and a score resulting from the execution of the
compiled Player program.  
The output score is not always given, but the examples are
all complete, and may be directly compiled and executed.
.NH
Introductory example
.LP
Here is the first program example.
The output generated by executing this program is given in Score Example 1.
.LP
.so ex/ex1
.LP
Notice that reserved words in the C language are printed in \fCugly constant
width font\fP.  Player constructs are in \fBbold\fP.
An important rule of thumb to remember is that 
all statements, subroutines, and variables that are
part of Player have their first letter Capitalized.
.LP
In that example, the statement:
.DS
.ft C
\fBPlayer\fP \fIbeep\fP(1.5, 100)
.ft R 
.DE
says \fIbeep\fP is a Player with a begin-time of 1.5 seconds,
and a duration of 100 seconds.
.LP
So what is a Player?
Well, for now let's say that it is the same as a subroutine with an
important difference.  A subroutine may only execute when control of
the CPU is given to it by its caller.  A Player, on the other hand,
can decide itself when it will execute.  In this case, it will be
executed once at time 1.5 seconds, and it may decide itself to be
reexecuted anytime thereafter as often as it likes over the duration of
100 seconds, after which it may not run any more.  The last
note that Player beep will play is guaranteed to end before 100
seconds has elapsed.  In this case, it will finish its last note before time 101.5
seconds.
Note that this implies that if beep wants
to play only one note lasting 100 seconds or more, 
it will not play anything.
.LP
The subroutine calls
\fBRhythms()\fP  and \fBPitches()\fP 
are provided in the Player runtime library and loaded automatically
when used in a Player program.  They
understand a format for specifying
rhythmic durations and pitches
called \fIcyclic list\fP format.  
Cyclic lists are
really C character strings in a particular format digestable by the
subroutines.  The \fBRhythms()\fP routine only understands cyclic lists
with \fBRhythm\fP-format expressions, and the \fBPitches()\fP routine
only understands \fBPitch\fP-format expressions.
.LP
Cyclic lists are made up of blank- or comma-separated fields.
Each field is an expression in a particular format for specifying
rhythmic or pitch values.
Each time a \fBPitches\fP() or \fBRhythms\fP()
subroutine is called with a cyclic list, the subroutine
draws the next element from the list and
evaluates it according to the expression rules it
understands.  The resulting value is returned, and
applied to the variable on the left
of the assignment operator.  
In this example,
for each call to \fBRhythms\fP, the implicitly declared
variable \fBP4\fP is assigned a rhythmic
duration, and
the variable \fBP5\fP is assigned a pitch value.
\fBPitches\fP() and \fBRhythms\fP() take pitch and rhythmic specification
in a textual form of common practice notation, and
return floating-point numbers which 
represent frequencies in Hz and durations in seconds.
.LP
Each time the Player returns (ceases executing), the value of these
\fBP\fP-variables\(emas they are called\(emare 
printed on the standard output
in the form of a \fIcmusic note statement\fP.
Repeated execution of the Player produces a time-ordered stream
of note-statements, called a \fIscore\fP.
By updating these \fBP\fP-variables through time, the Player
can generate an arbitrary score for cmusic.
.LP
A cmusic note statement is a sequence of
blank- or comma-separated fields, called P-fields.
Here is an example:
.DS
	note, 0 beep 1.0 440Hz \(mi6dB;
.DE
The word \fInote\fP corresponds to the first P-field, and is called
\fBP1\fP.  \fBP2\fP and \fBP4\fP are always arithmetic expressions
specifying a begin time and duration, respectively.  \fBP3\fP is
always a symbol denoting the name of the instrument to synthesize
the sound.  P-fields from \fBP5\fP on up are not designated, and are
usually used to communicate information pecular to the particular
sound synthesis algorithm employed.  In each Player, there
is a set of intrinsically declared variables called \fBP\fP-variables 
which are printed at the end of each execution of the Player in
cmusic note-statement format.  
.LP
In our example, the fourth parameter field of the note statements
generated by this Player will show a duration
in seconds corresponding to the sequence of durations assigned to 
the \fBP\fP-variable \fBP4\fP,
and the pitch values will be in P-field 5, corresponding to 
\fBP\fP-variable \fBP5\fP.
.LP
The sequence of values in the cyclic list passed to the
\fBRhythms\fP() routine specifies a sequence of rhythms.  
In the simple case,
rhythmic durations are specified as the denominator of the common practice
fractional notation for rhythms, e.g.
a quarter note is designated 
simply by  \fB4\fP, an eighth note by  \fB8\fP, etc.  
A  quarter note lasts 1 second, an 8th note .5 seconds, a 
whole note 4 seconds.  We can show this in algebraic form as
.EQ
D~=~{4 over {down 60 N}}
.EN
where $D$ is the duration in seconds, and $N$ is the specified common
practice rhythmic notation.  For instance, a quarter note is $4/4=1$
second, a whole note is $4/1=4$ seconds.
Later examples will show how to achieve arbitrary rhythmic values easily.
.LP
Within Pitches and Rhythms statements, ``{}'' characters are used to
group rhythmic or melodic sets.  The ``x2'' after the `}' character
indicates that the set of pitches is to be repeated twice.
Notice that sets can be nested. 
If we expand the curly-braces in this rhythmic cyclic list:
.DS
	{1 2 {4 8 8 4}x2 1}x2 16 16
.DE
we get the sequence
.DS
	1 2 4 8 8 4 4 8 8 4 1 1 2 4 8 8 4 4 8 8 4 1 16 16
.DE
No curly-braces are needed around sets that are not repeated.
When converted to a sequence of durations by the \fBRhythms\fP()
routine, we get 
.DS
	4 2 1 .5 .5 1 1 .5 .5 1 4 4 2 1 .5 .5 1 1 .5 .5 1 4 .25 .25
.DE
which is a sequence of durations in seconds.  
The sum of these durations, 32.5 seconds, 
is the length of time
this example Player will take to get through this rhythmic phrase.
But the Player won't stop until it has run for 100 seconds.  After
reaching the end of this rhythmic phrase, the very next call to
\fBRhythms\fP() will wrap around from the end of the list to its
beginning again; hence the name, \fIcyclic list\fP.
.LP
Pitches are specified as a pitch class, optional accidental and optional
octave.  The value of the pitch  \fBa4\fP  is the number 440.0. 
\fBa2\fP evaluates to 220.0, and so on.
Accidentals are the characters
\fBs\fP and \fBf\fP for sharp and flat, respectively.  Enharmonic
pitch classes are handled (\fBff\fP for instance, is \fIf-flat\fP).
Double-sharps and double-flats are represented by doubling the accidental,
e.g., \fBcss\fP is \fIC-double-sharp\fP.
There is a notion of a \fIcurrent octave\fP, so that if one is not
specified, it is supplied automatically.
The default octive is the 4th piano octave, beginning
on \fImiddle-C\fP.
So for instance, when spelled out, the sequence
.DS
	as b3 css df5 e f fs ff3 bs6 a8
.DE
is really
.DS
	as4 b3 css3 df5 e5 f5 fs5 ff3 bs6 a8.
.DE
Besides setting the default octave by explicitly naming it, one
can supply ``$+$'' and ``\(mi'' instead to make the new current octave
relative to the previous one.
For instance, here is the previous example with relative octaves:
.DS
	as  \(mib css++  df e f fs  \(mi\|\(miff  +++bs  ++a.
.DE
Note that prefixing the ``$+$'' or ``$-$'' to a pitch has the effect
of changing the default octave before the pitch is evaluated, whereas 
putting the ``$+$'' and ``$-$'' after the pitch changes the default
octave after the pitch is evaluated (and before the next one is
evaluated).  This is done in the spirit of the C programming language
auto-increment/decrement.  Unlike that provision in C, any number
of ``$+$'' and ``$-$'' characters may appear.  Each has the
effect of changing the default octave by one.
.LP
Next, the statement:
.DS
\fBP2\fP = \fBAbs_time\fP();
.DE
sets the value of \fBP2\fP to the value of current time.
The routine \fBAbs_time\fP() 
always returns
the current elapsed time.  The first time this statement is executed,
\fBAbs_time\fP() will return 1.5, because that is the first time
this Player will be run.
This statement sets the
value of the second P-field in the note statement
that will be printed, which is the field
that cmusic uses to establish the
begin-time of a note.  
.LP
Lastly, the statement
.DS 
.ft C
	\fBWait_until\fP(\fBP2\fP + \fBP4\fP);
.ft R 
.DE
informs the run-time scheduler\(emwhich
is responsible for executing Players\(emthat this Player wishes to run again
at time \fBP2\fP+\fBP4\fP.  This means that the Player wishes to run again
as soon as duration of the current note statement elapses.
.LP
You can enter this example into a file and compile and run it to get
the score which is shown below.
The file name should end
with a suffix of ``.P'', for instance, ``beep.P''.  
When it is entered, compile it by saying
.DS
% Player beep.P
.DE
The result of compiling this program is a file 
called \fIa.out\fP in your directory.
When you execute it, 
.DS
% a.out
.DE
it will produce a score on the standard output.
If you wish to capture the score in a file, redirect the
output.  For instance, 
.DS
% a.out > foo
.DE
will capture the output in file ``foo''.
.LP
Here is some of the score this Player will produce.
.DS
note,  1.500, beep,  4.000, 466.164;
note,  5.500, beep,  2.000, 246.942;
note,  7.500, beep,  1.000, 146.832;
note,  8.500, beep,  0.500, 554.365;
note,  9.000, beep,  0.500, 659.255;
note,  9.500, beep,  1.000, 698.456;
note, 10.500, beep,  1.000, 739.989;
note, 11.500, beep,  0.500, 164.814;
note, 12.000, beep,  0.500, 1046.502;
note, 12.500, beep,  1.000, 7458.620;
note, 13.500, beep,  4.000, 7458.620;
note, 17.500, beep,  4.000, 130.813;
note, 21.500, beep,  2.000, 146.832;
note, 23.500, beep,  1.000, 554.365;
note, 24.500, beep,  0.500, 659.255;
note, 25.000, beep,  0.500, 659.255;
note, 25.500, beep,  1.000, 739.989;
note, 26.500, beep,  1.000, 164.814;
note, 27.500, beep,  0.500, 1046.502;
note, 28.000, beep,  0.500, 7458.620;
note, 28.500, beep,  1.000, 7458.620;
note, 29.500, beep,  4.000, 130.813;
note, 33.500, beep,  0.250, 146.832;
note, 33.750, beep,  0.250, 554.365;
note, 34.000, beep,  4.000, 659.255;
note, 38.000, beep,  2.000, 659.255;
note, 40.000, beep,  1.000, 739.989;
note, 41.000, beep,  0.500, 164.814;
note, 41.500, beep,  0.500, 1046.502;
.sp
and so on.
.NS 1
.DE
.NH
Stop, Hold, and Kill in Cyclic Lists
.LP
If the symbol \fBStop\fP or \fBKill\fP, appears 
in a cyclic list passed to \fBRhythms\fP()
or \fBPitches\fP(), when it is scanned it will cause the
Player executing the routine to
cease execution.
.LP
When any routine which reads a cyclic list encounters
the symbol \fBStop\fP, the routine tells the Player scheduler
that when this Player returns (i.e., its subroutine has either
executed a \fBReturn\fP statement, or ``fallen off the bottom''), 
it should be stopped.
\fBStop\fPping a Player means that,
even if it is scheduled to run again by itself or another Player,
the scheduler will 
refuse to do so, so long as the Player is \fBStop\fPped.  There are ways
for a stopped Player to be restarted by other Players.
.LP
When any routine which reads a cyclic list encounters
the symbol \fBKill\fP, the routine tells the Player scheduler
that when this Player returns, it should never be executed again.
All memory resources, and all requests by the Player to be scheduled
will deleted immediately after the Player that reads \fBKill\fP in a cyclic list
returns.  A \fBKill\fPed Player can not be restarted by other Players.
(However, it is possible for a Player to test before it returns
that it is to be \fBKill\fPed, and undo this status.)
.LP
In this next example, as in the last,
there are fewer fields in the cyclic list passed
to \fBPitches\fP() than to \fBRhythms\fP().
The three Pitches will be cycled through repeatedly until the Player is
terminated by the \fBKill\fP expression.  Examine the score to observe
how the sequence of pitches precesses the sequence of durations.
.LP
Sets of Pitches or Rhythms can consist entirely
of other sets.  In this example, the cyclic list given to
\fBRhythms\fP() could have more
concisely have been written
.DS 
.ft C
\fBP4\fP = \fBRhythms\fP("{4 8 8 4}x4 \fBKill\fP");
.ft R 
.DE
.LP
.so ex/ex2
.LP
.DS
note,  1.500, beep,  1.000, 466.164;
note,  2.500, beep,  0.500, 246.942;
note,  3.000, beep,  0.500, 261.626;
note,  3.500, beep,  1.000, 466.164;
note,  4.500, beep,  1.000, 246.942;
note,  5.500, beep,  0.500, 261.626;
note,  6.000, beep,  0.500, 466.164;
note,  6.500, beep,  1.000, 246.942;
note,  7.500, beep,  1.000, 261.626;
note,  8.500, beep,  0.500, 466.164;
note,  9.000, beep,  0.500, 246.942;
note,  9.500, beep,  1.000, 261.626;
note, 10.500, beep,  1.000, 466.164;
note, 11.500, beep,  0.500, 246.942;
note, 12.000, beep,  0.500, 261.626;
note, 12.500, beep,  1.000, 466.164;
.NS 1
.DE
To keep the clutter down, from here on the scores are quarantined to Appendix 1.
Scores for all complete examples are given there.
.LP
If the symbol \fBHold\fP appears in a cyclic list, the effect is that
the immediately previous value is repeatedly returned.  If the
cyclic list above had been \fH"as b3 c\fP \fBHold\fP\fH"\fP, then from the
third note on, the pitch \fHc\fP would have been returned.
.NH
Delimiters in cyclic lists
.LP
Commas as well as blanks can be used to separate expressions in
\fBRhythms\fP and \fBPitches\fP statements.  
Sets in ``\fH{}\fP'' can contain as little
as one element, as in \fH{4}x2\fP, which puts out two quarter-notes.
.so ex/ex3
.LP
.NH
Once-only blocks, P, Ps and Pp variables
.LP
Inside a Player, the block of statements beginning with \fBP_start\fP
and enclosed in curly-braces
will only be executed on the first call to the Player, and ignored on
all subsequent calls.
.DS 
.ft C
\fBP_start\fP {
	\fBPp5\fP = "Hz";
	\fBPs6\fP = "f1";
}
.ft R 
.DE
.LP
\fBP-\fPvariables come in different types.  You've seen the \fBP\fIn\fR
variables (where \fIn\fP is a small positive integer)
used in previous examples to store floating-point numbers
that will subsequently be formatted into the \fIn\fPth position in
the resulting note statement.  There is also a set of character
string \fBP\fP-variables, called \fBPs\fIn\fR where again, \fIn\fP
is a small positive integer, specifying where the contents of the
string will appear in the resulting note statement.
Another \fBP\fP-variable set is the \fBPp\fIn\fR variables.  These
can be used to attach postoperators such as "Hz" and "dB" to a field of a
note statement.
The parameter \fBP5\fP, for
example, refers to the floating point register for the fifth field
of a note statement.  The string
register for this field is called \fBPs5\fP.  The postfix string is 
called \fBPp5\fP.  If
the value of the information to be printed in the \fIn\fPth
field of a note statement is
numeric, use the \fBP\fIn\fR variable.
If it is to be a character string,
use the  appropriately numbered \fBPs\fIn\fR  variable.  
If either the numeric or string value for the \fIn\fPth
parameter is to have a postoperator, that can be placed in the \fBPp\fIn\fR
register, and it will be concatenated to the 
like-numbered \fBP\fIn\fR  or  \fBPs\fIn\fR  register.  
In the example below, the frequencies printed in P-field
5 will have the string "Hz"
concatenated.  The sixth parameter field will be the string "f1".  
If \fBP6\fP and \fBPs6\fP were both used, Player would have chosen to print
the string in \fBPs6\fP and would have ignored the floating-point value 
in \fBP6\fP.
.so ex/ex4
.NH
Multiple Players, Default Begin/Duration Times
.LP
Any number of Players may exist within a program.  They may be in the
same file, or separate files, to be compiled and linked together later.
While it is ordinary to supply both the begin time and duration of a Player,
this is sometimes redundant, as when a \fBKill\fP or \fBStop\fP expression exists in a
cyclic list.  Thus, the duration can be left out in these
circumstances.  (N.B., if the duration is ommitted,
a \fBKill\fP or \fBStop\fP expression must appear somewhere
or the Player may never stop!)
.LP
Player \fIbeep\fP starts beeping at 1.5 seconds and goes until the \fBKill\fP
is scanned.
Player \fIblat\fP starts at time 0.  As they play the same cyclic lists,
they execute a canon.
.so ex/ex5
.NH
Functions
.LP
The statement:
.DS
.ft C
\fBInstance\fP \fBFunction\fP *f1;
.ft R
.DE
declares that the variable \fBf1\fP will point to a \fBFunction\fP.  
A \fBFunction\fP can hold an array of floating point values such as those
produced by the \fIgen\fP(1CARL) programs.
The designation 
\fBInstance\fP says we want the contents of this variable to be saved
in between the times that this Player is executed.  
While the contents of the \fBP\fP-variables is automatically saved from
one call to a Player to the next, any other \fCauto\fP storage-class 
variables declared in the Player subroutine are not saved
unless they are given the \fBInstance\fP storage class.
.LP
In the next example,  we will read a file named "ramp" in
the \fBP_start\fP block.  The file has 
previously been created using \fIgen1\fP(1CARL) by the command:
.DS
% gen1 \-L24 0 0 1 1 > ramp
.DE
which created 24 floating point numbers ramping from 0 to 1.
The \fBFunction\fP pointer \fIf1\fP will
be given the address of the array of floating point values after the
procedure \fBRead_Gen()\fP has read in the file.  
We can access the \fBFunction\fP in \fIf1\fP with the statement like
.DS
.ft C
\fBP6\fP = \fBFunc\fP(f1, 5.0);
.ft R
.DE
which looks up the $y$-value of the \fBFunction\fP at $x~=~5.0$
and puts it
in \fBP6\fP.  N.B. the second argument to \fBFunc\fP()
must be a \fCfloat\fP or a \fCdouble\fP.  C does not typecast arguments
to procedures.  
The reason it takes a \fCfloat\fP as its index is because we can say, 
for instance,
.DS
.ft C
	\fBP6\fP = \fBFunc\fP(f1, 5.4);
.ft R
.DE
which interpolates linearly by .4 
between the value of the \fBFunction\fP at 5 and the
value at 6.
.so ex/ex6
.NH
Relative time, and Functions
.LP
A subroutine called \fBRel_time\fP() exists which,
as the Player goes from
its first call to its last, returns a number which goes proportionately
from 0.0 to nearly 1.0,
giving a running indication of where we are in the life of this Player.
For example, say we have a declaration,
.DS
.ft C
	\fBPlayer\fP \fIblat\fP(0, 100)\fR.
.ft R
.DE
Player \fIblat\fP 
plays notes whose begin times go from 0 to something less than 100 seconds.
\fBRel_time\fP() will return values from 0 to something less than 1.0
over this same duration.  
The value returned from \fBRel_time\fP() will
never reach 1.0 because the Player is guaranteed to
finish its last note before the expiration of its duration.
Let $epsilon$ stand for the difference between
1.0 and the actual value returned by \fBRel_time\fP() on the last call
to Player \fIblat\fP.
Then
.EQ
epsilon~=~{{D-({B sub D} - {B sub 0})} over {down 60 D}}
.EN
where $D$ is the duration of the Player, $B sub D$ is the
begin time of the last call to this Player, and $B sub 0$ is
the begin time of the first call.  
In this example,
.so ex/ex7
the last note statement of this Player will have a begin time
of 99 seconds, and the value printed in \fBP5\fP will be .99.
.LP
There is a version of the \fBFunc\fP() procedure, called
\fBRel_Func\fP(), which scales the \fIx\fP-axis of the Function
to lie in the [0.0, 1.0) interval.  
Using \fBRel_time\fP() to index a 
Function with
\fBRel_Func\fP() will cause the Function to be perambulated exactly once
during the life of the Player.  Thus, it represents a convenient way to
control functions that are to be applied over a run of note statements,
such as amplitude control, etc.
.so ex/ex8
.LP
N.B., \fBRel_time\fP() depends heavily on supplying a duration
to the Player.  When the duration is left out, 
the Player can run forever.
Progress of any piece when
measured against infinity will seem small, hence \fBRel_time\fP() will
always be near 0 unless a duration is given.
.LP
Also, the value of the index supplied to \fBRel_func\fP() must be
a \fCfloat\fP or \fCdouble\fP.
.LP
Note that in the above example, the Function pointer \fBf1\fP
is given an \fBInstance\fP storage class because we want its
value to be preserved over multiple executions of this Player.
The variable \fCy\fP, on the other hand, is a regular \fCauto\fP
storage class because we don't care to preserve its value over
multiple executions since we recompute its value each time.
.NH
Gen statements within Players; more about rhythms
.LP
Calls to \fIgen1\fP, \fIgen2\fP, etc.
can be made directly within a Player.  The format of the call
is exactly as it would be given to the shell.
Thus, we have the statement 
.DS 
.ft C
f1 = \fBGen\fP("gen1 \-L20 0 1 4 2 9 10 19 20");
.ft R 
.DE
which is equivalent to the shell command:
.DS
% gen1 \-L20 0 1 4 2 9 10 19 20
.DE
The difference, of course, is that the first returns a pointer to the
resulting Function within a Player.
.LP
The next example shows more of the syntax for \fBRhythm\fP format
cyclic lists.  
Rhythmic values can be dotted.  The notation \fH4.\fP implies a
duration of three 8th-notes.  Also, a rhythmic value can be
specified as a fraction.  We observed above that the rhythmic expression
\fH4\fP equals a duration of ${4 over {down 60 4}}~=~1$ second.  This can be
stated explicitly as a rhythmic expression, \fH4/4\fP which will yield
the same value as simply saying \fH4\fP.  
However, any value can be substituted
for the numerator.  For example, the rhythmic expression \fH2/4\fP yields
a duration of a half-note, which equals 2 seconds.  Thus, it is like
saying ``two quarter-notes tied''.
The expression \fH3/8\fP is ``three eights tied'', and is
equivalent to the \fH4.\fP notation.  Thus, the fractional notation
for durations is more flexible than the dotted notation, as one can
say, for instance, \fH17/16\fP to get seventeen sixteenth-notes tied,
which equals a whole note tied to a 16th.
Any number of dots may follow a rhythmic value.  Each dot adds half again
to the value of a rhythm, e.g., $\fH2.\fP~=~1/2 + 1/4~=~\fH3/4\fP$, 
and $\fH2..\fP~=~1/2 + 1/4 + 1/8~=~\fH7/8\fP$.
.LP
One may specify triplet 8th-notes as \fH12\fPth notes, as there are
12 of them in a whole note (just as there are 4 quarters in a whole
note, and hence we say \fH4\fP to represent it).  One can get quite
wild with this, for instance, a septuplet 8-th note is \fH14\fP.
Even with all this, there are some compound rhythms which are difficult
to specify, such as a doubly-dotted triplet-eight tied to a quintuplet
quarter-note.  (Mercifully this does not arise often!)  However, you
may beat back the complexity with an expression such as \fH12..+5\fP
if you like.  The precedence of \fBRhythm\fP-format operators
is ``\fB.\fP'', then ``\fB/\fP'', lastly ``\fB+\fP''.
.LP
In \fBPitch\fP-format cyclic lists,
an  \fHr\fP  expression stands for ``rest''.
In the example below,
the corresponding duration in the \fBRhythm\fP-expression cyclic list 
will specify the duration of the rest.
When the rest symbol is encountered,
all statements in the Player are executed normally, but the
result is simply not printed out.
.LP
Ordinarily, the note statement generated
prints from \fBP1\fP up to the highest
numbered P-field referenced.  This can be changed by
calling the routine
\fBHipn\fP()  and passing it the highest P-field to be
printed.  In this example, even though \fBP20\fP is used, only the first 6 
P-fields will be printed.  \fBHipn\fP() takes two arguments,
a pointer to the Player instance to be affected, and an integer specifying
the highest parameter to print in a notelist.
.so ex/ex9
.NH
Motivic interpolation
.LP
Here is an application of simple algorithmic elaboration of motivic
materials.
An interpolation between motives is possible using the numeric
format of pitches and rhythms.  In this example, the first rhythmic
phrase, \fH16 4. 8\fP, is gradually interpolated into \fH8 4. 16\fP,
its retrograde.  The melodic phrase is likewise interpolated to
its retrograde.
.so ex/ex10
.LP
The interpolation is applied as a continuous function over
the life of \fIphrase\fP's execution.  It is interesting to examine the
output of this Player.  
The first two durations end up unchanged because the amount by which
they are interpolated is not reflected in three digits of precision.
But the third value, .5 (corresponding to the 8th-note), is changed to .482
when it first occurrs in note-statement three. 
It is starting to interpolate towards the 16th-note it will become
in the retrograde form.  The value of the \fH4.\fP remains constant, as
its target in the retrograde is also \fH4.\fP, i.e., a dotted-quarter's
duration.  
.LP
When we look at the end,
we see that the values have roughly retrograded, but not quite hit
their mark: .459 should have been .5, and .27 should have been .25.
This is because of \fBRel_time\fP().  
Remember that \fBRel_time\fP() returns the current time scaled to
the interval [0, 1), but it never actually reaches 1, because that would
require that it play beyond its duration limit.  
The value of
\fBRel_time\fP() is printed separately in \fBP6\fP to show what it does.
Because it doesn't reach 1.0, our interpolation never reaches perfect
closure.  Can you think of a way to make it close?
.LP
Another problem with this example is that there is no measure taken to
make the last note played be the third note of the final retrograde.
Is there a fix for this?
.NH
The Exprs cyclic list statement
.LP
Another cyclic list statement is \fBExprs\fP, which takes a cyclic list
of arithmetic expressions and otherwise behaves like \fBPitches\fP and 
\fBRhythms\fP.
This is useful for situations where \fBPitches\fP and \fBRhythms\fP 
would present difficulties to specify the right value.
.so ex/ex11
.LP
The format of expressions is as described in \fIexpr\fP(1CARL).
.[
startup kit
.]
.NH
Stochastic procedures
.LP
Access to a library of stochastic procedures is also provided to Player
by way of \fIlibcarl\fP(3CARL).  Routines from this
library, as well as the UNIX math library, \fIlibm.a\fP(3), are
automatically loaded without having
to specify a loader flag to the Player compiler.
The appropriate header files are also automatically loaded by the 
C language preprocessor so the types of the return values of the
library routines will be correct.
All the ``stochastic canons'' described in \fIcannon\fP(1CARL)
and \fIlibran\fP(3CARL)
manual pages are available.
.[
startup kit
.]
.LP
In this example, we use two \fBExprs\fP statements to create the upper and
lower bounds of a moving random selection range.  In this case the
range remains constant, but the bounds go in the sequence [0, 1], [1, 2],
[2, 3], etc.  These boundary values are applied to the \fIfrand\fP() uniform
random number generator, drawn from \fIlibcarl.a\fP.  
Thus, \fIfrand\fP() will return random values in
the range [0, 1], then [1, 2], etc.  This value is applied to \fBP4\fP, so the
duration of each succeeding note will average 1 second longer (over
many trials).
.LP
\fBP5\fP is given successive random values as returned from the \fIcauchy\fP()
distribution function.  All stochastic cannons require that the first
argument specify a procedure that they are to use as a source of random
values.  In this case, \fIfrand\fP() is chosen.  \fBP6\fP 
gets values obtained from
driving the \fIgamma\fP() distribution function with the 1/f-noise generator,
\fIonefrand\fP().  Finally, \fBP7\fP gets a value of 1/f-noise 
selected to lie in
the range of values previously applied to \fBP5\fP and \fBP6\fP.
.so ex/ex12
Notice that the declaration of \fClower\fP and \fCupper\fP are
standard C \fCauto\fP declarations.  This is because we 
always regenerate new values to put in these variables each time
the Player is called, and never test the value before setting it
each time.  Thus, the values do not need to be stored across calls
to this Player, and therefor need not be declared \fBInstance\fP.
.NH
Strings statement
.LP
Another cyclic list format is for the  \fBStrings\fP() routine.
It takes a generic cyclic list and sequentially returns string pointers
to null-terminated copies of the individual fields of the cyclic list.
Its output must be
directed into a string pointer variable.
In the example, \fBPs5\fP is used.  
As with the other cyclic lists, the symbol  \fBKill\fP  terminates the Player
wherever encountered.
.so ex/ex13
.LP
.NH
Once-only procedures
.LP
You might have occasion to want to do certain actions before any Player
is run, or to do some action after the last Player is done.  Statements
in the procedure \fBM_start\fP() are executed after the Players are cueued,
but before any are run.  In this instance, we print a string which will
set the sample rate in cmusic.  We then modify the pitches in the
array used for specifying the translation from \fBPitch\fP-format
cyclic lists to frequency numbers.
As a result of this assignment, any
reference to the pitch  \fBa4\fP  in any octave will return a value of 220.0
instead of 440.0.
.LP
The procedure \fBM_ter\fP() is executed after the last Player.
We use it to print ``ter;'', which causes cmusic to know the score is ended.
.LP
Notice that \fBM_start\fP() and \fBM_ter\fP() are procedures, and must have
parenthesis after their names, whereas \fBP_start\fP is just a symbol that
appears at the head of a block inside a Player, and does not have
parenthesis following.
.so ex/ex14
.LP
Notice that the constant variable assigned to \fBP4\fP is an integer.
This is ok, as C typecasts the integer automatically into a float
before storing it.  In general, the only place where C does not typecast
automatically is arguments to subroutines.
.NH
Reading cyclic lists from files
.LP
Cyclic lists can be stored in text files for retreival by Players.
In this example, a file named \fInotefile\fP is read.
Here is the contents of the file:
.DS
.ft C
vln1not: as a a b c gs g3 end;
vln1rhy: 4 8 8 12 12 12 1;
vln1num: \(mi6dB sin(.707) ln(2) 48K;
vln1str: "f1" "amp" "skew";
.ft R
.DE
The structure of a cyclic list in such a file is a label
terminated with a colon, then the cyclic list, then a semicolon
to terminate the list.
In this example program \fBRead_list\fP() 
reads the file named in the first argument, 
extracting the cyclic list named in the second.  The cyclic lists
so extracted are put in the symbol table under the name of their labels,
and can be accessed by another cyclic list via the ``\fH@\fP''
operator.
.so ex/ex15
.LP
.NH
Reading the command line from a Player
.LP
The command line arguments to the program that runs the Players
are available to the Players.  The count is in the global variable
\fCArgc\fP, the string
arguments are in \fCArgv\fP.  This Player simply prints out the command
line arguments and stops.
.so ex/ex16
.LP
The Player program is executed like this:
.DS
% a.out one two three
.DE
and it prints
.DS
a.out one two three
.DE
.LP
The statement \fBKill\fP(\fBSelf\fP); told the Player scheduler to do the
same thing that a \fBRhythms\fP() routine\(emor other cyclic list 
evaluator\(emwould do upon scanning the symbol \fBKill\fP.  
The variable \fBSelf\fP
tells the scheduler whom to kill, i.e., stop the currently executing
Player.
.NH
Player instances, more arguments to Players
.LP
So far, we have maintained the polite fiction that a Player is simply
a subroutine that can schedule its own execution in time.  In fact, 
the subroutine which is defined for a Player is
a \fItemplate\fP for a \fIclass\fP of potential Player \fIinstances\fP.
The template is used to create 
instances of the Player class.
The instances of the Player class
are what actually get executed.
The Player subroutine
defines the \fIclass\fP, of which the instances are all members.
Any number of instances of a Player may coexist simultaneously.
Remember the old fairytale about the troll with three heads and
but one eye?  That's the idea.
So far, we have only given examples were there was one instance per class.
Let us begin the discussion of multiple instances per Player class
by describing the full list of
arguments which a Player may have.
.LP
Player declarations may have zero to four arguments.  
These arguments have implicit type declarations that you need not supply.
.RS
.SH
Zero arguments
.LP
The effect of zero arguments is that the Player class is defined by
the subroutine given, but no instances of that class are created.
So saying,
.DS
.ft C
\fBPlayer\fP \fIclash\fP()
{
	/*\fI some code or other \fP*/
}
.ft R
.DE
declares the Player class, and
defines its template, but does not instantiate
anything.
.SH
One argument
.LP
If one argument is given, the result is the same as for zero arguments,
except that one Player instance is created with the stated begin-time,
and an infinite duration.
.SH
Two arguments
.LP
This is the same as above, but the one Player instantiated is 
given the stated duration.
.SH
Three arguments
.LP
The third argument sets the initial running status of the instantiated
Player.  Ordinarily, this defaults to \fBP_READY\fP. 
This means that the instantiated Player may be picked by the 
scheduler to run over the interval of its begin-time and duration.
If the third argument is \fBP_STOPPED\fP, the
scheduler will ignore all requests to schedule this Player instance.
(Another Player could change its running status
back to \fBP_RUNNING\fP at some appropriate moment, for instance.)
.SH
Four arguments
.LP
The fourth argument specifies how many Player instances of this class
to instantiate.  For instance,
.so ex/ex17
will instantiate 10 Players of this class, each of which will play
ten notes.
.RE
.LP
.NH
New_player \(em dynamic instantiation of Players
.LP
A Player may instantiate new Players at any time via the \fBNew_player\fP()
routine.  For instance, one could define a Player named \fIpart\fP and
dynamically instantiate as many of them as were needed to play a particular 
composition, based on information contained in the score, or supplied
on the command line of the executed Player program.  
.LP
The arguments to \fBNew_player\fP() are:
the address of the class procedure for the Player being instantiated,
its begin time, duration, and initial running status.
The value returned is a pointer to the instance data of the instantiated
Player.
.LP
In the following example, the command line is read by Player \fIagent\fP,
to determine the number of Players, named \fIpart\fP,
to be dynamically allocated to play simultaneously.
Each Player \fIpart\fP will play the same note sequence, with
random begin-time, instituting a kind of canon with a random offset.  
Since \fIpart\fP has a \fBKill\fP in it, the
duration of each instance of \fIpart\fP is set to \fBForever\fP, which
allows the instances to run until they \fBKill\fP themselves.
.so ex/ex18
.LP
The significance of the \fCMalCpy\fP macro may be puzzling.
The Player cyclic list routines distinguish the different cyclic lists by
the address of the string which is passed to the routines.  In this case,
we have multiple Player 
instances sharing the same \fBPitches\fP and \fBRhythms\fP strings.
If multiple Players share the same cyclic list
string address, then they play a hocket, each picking up where the other left
off in the cyclic list.  If we don't want this, i.e., we want all instances
to play the whole list in canon, we must give the instances separate copies of
the cyclic list so the lists will have different addresses.  The \fCMalCpy\fP
macro claims memory and copies the string for each instance when the
instance runs its \fBP_start\fP block.  Thus, they play a canon, as opposed
to a hocket.  (The \fCMalCpy\fP macro is included in Player.h; it is given
here just for clarity.)
.LP
Note the time signature
in the \fBRhythms\fP routine: \fHT4/8\fP, indicating the usual ``four
beats, quarter-note gets the beat'' arrangement.  This information is
advisory only; the \fBRhythms\fP routine does nothing currently except
store this information.  
It can be used to implement measure beat checking.
The vertical bars
are measure marks.  There is a key signature
in the \fBPitches\fP routine that sets the key to one sharp: \fHK1s\fP.  
Because of the key signature,
the \fHf\fP in this cyclic list will actually be \fHfs\fP.  When using
key signatures, accidentals override the signature until the next measure
mark, when they are cleared.
.LP
The \fIagent\fP first checks that the appropriate argument is available;
if not it calls \fBPexit\fP(), which is the proper way to exit a Player
program.  (Actually, it doesn't matter in the timesharing version whether
\fIexit\fP(2) or \fBPexit\fP() is called, but it does matter in the
realtime version; so it is a good habit to develop.)
It then loops, creating the Players with a random begin-time.
Just to shoehorn another feature of Player into this example, we have
\fIagent\fP set \fBP5\fP of the newly instantiated Player with \fBSet_p\fP()
to the value of \fCi\fP.  As the third argument to \fBSet_p\fP() is
a \fCdouble\fP, we must typecast the value of \fCi\fP because C does
no automatic type coercion of actual parameters to functions.
.LP
After instantiating all the Players,
\fIagent\fP terminates itself, as it is no longer needed.  (Would
that agents were so dedicated in real life!)
As an alternative, if instead of calling \fBKill\fP(), \fIagent\fP had the
statement
.DS
.ft C
	\fBJoin\fP(\fBALL_CHILDREN\fP);
.ft R
.DE
then it would be run after the last child finished.
Were it to have said
.DS
.ft C
	\fBJoin\fP(\fBEACH_CHILD\fP);
.ft R
.DE
then it would be run after each child terminated.
.LP
N.B., \fBJoin\fP() only reschedules the parent when the child process
terminates by being \fBKill\fPed.  There are three typical ways a Player
process can be \fBKill\fPed.  First, if a Player calls \fBKill\fP(), or if
a cyclic list routine scans \fBKill\fP in a cyclic list, or if a Player attempts
to execute outside its time execution window.  Other ways a Player can be
killed include if another Player calls \fBKill\fP() with the
address of another Player instance.  A Player is NOT killed if it is \fBStop\fPped,
but is only suspended, and may be resumed.
.LP
Child processes can determine who their parent is with the routine
\fBCaller\fP().  For instance, the statement
.DS
.ft C
	\fBCaller\fP(\fBSelf\fP);
.ft R
.DE
in \fIpart\fP would return a pointer to \fIagent\fP's instance data.
.NH
Access to other Player's P-variables
.LP
The \fBP\fP-variables of one Player can be examined by another by use of
the Player routines \fBP\fP(), \fBPs\fP() and \fBPp\fP().  
These routines take as arguments a pointer to a Player instance, and
the index of the \fBP\fP-variable to fetch, and they return the
appropriate value from that Player instance.
.LP
For a simple example, suppose we have sevearl
Player instances of a Player class \fIdrawer\fP each of which
computes a random value into one of its \fBP\fP\fIn\fP
fields each time it is run.
Say we wished a different Player to be able periodically to find out the values
being used by all instances of \fIdrawer\fP, say once every
second.  In order to do this, we must be able to get a list of the
current instances of a Player class.  This is accomplished by the
routine \fBInstances\fP().  This routine takes as argument the name of
the Player class subroutine, and returns a pointer to the head of a list of
instances of that class.  The routine \fBNext_instance\fP() simply returns
the next instance pointer on the list, or \fCNULL\fP if we have
reached the end of the list.  In this example, Player \fIlooker\fP
will print out the value of \fBP5\fP of each instance of
\fIdrawer\fP once every second.  
.LP
.so ex/ex19
.LP
The declaration \fBPlayer \fC*p;\fR says that the variable \fBp\fP
is a pointer to a Player (technically, a pointer to a Player instance).  
In the \fCfor\fR loop, \fBp\fR
is initialized to the head of the list of pointers to instances of
class \fIdrawer\fP.  For each instance, if \fBp\fP
is not \fCNULL\fP (i.e., there are
instances of this class), then it prints \fBP5\fP of that instance.
The routine \fBNext_instance\fP() simply takes the pointer to the current
instance on the list, and returns the next element on the list.
.LP
This example shows that the internal state of Player instances can be observed, and
used to control the evolution of other Players.  Player \fIdrawer\fP could
be used to control the tempo of Player \fBlooker\fP, for an obvious instance.
.NH
Labels in cyclic lists
.LP
Labels may appear at the head of regular cyclic lists as well as in
files of lists.  These labels may be referred to in later cyclic lists,
and the labeled list, with the label removed, is inserted in the
later list.
In the example below, the label \fImotive1\fP is referred to again in the next
cyclic list.  The construct \fHlabel_name:\fP is used to
define a motive.  The construct \fH@label_name\fP is used to
refer to an existing motive.  The entire motive, minus the
label, but complete with repeats
and possible references to other motives, is copied into the right
place in the list being formed.  The expanded note sequence for \fBP6\fP 
will be:
.DS
a as a c cs d e d e f as a c cs d e d e f b Kill.
.DE
.so ex/ex20
.NH
Motives
.LP
The \fBMotive\fP() routine simply defines a cyclic list, and makes it
available for later use with \fH@\fP expansion.  
\fBMotive\fP() does not care what format
of list it gets,  as it does not traverse it
the way \fBPitches\fP() and friends do.  
Thus, in the example below, \fHx\fP, \fHy\fP and
\fHz\fP are defined as labeled cyclic lists in \fBMotive\fP without being used 
immediately.  These motive statements are put in an
\fBM_start\fP() block so as to make them globally
available before any references to them could be made by Players.
.LP
The procedure \fCtranspose\fP() is an example of pitch 
transposition.
The variable \fClevel\fP is the number of half-steps to transpose.
N.B., the value passed to \fClevel\fP 
must be a floating point number.  In this case,
7.0, corresponds to a transposition up by the interval of a fifth.
.so ex/ex21
.LP
The routine \fCtranspose\fP could also have been given as a macro:
.DS
.ft C
# define transpose(note, level) ((note) * pow(2.0, (level)/12.0))
.ft R
.DE
.NH
Rest() and Silent()
.LP
There is a procedure, \fBRest\fP(), which when called, has the same effect
as an  \fHr\fP  expression in a \fBPitch\fP cyclic list, 
i.e., it causes the Player
to not print its P-fields after computing them.  
You could, for instance,
execute \fBRest\fP() in an \fCif\fP statement to coerce a rest at other times
than as indicated in a \fBPitches\fP statement.  
A companion routine, \fBResting\fP() tests whether any Player is currently
executing a rest.
.LP
In the usage shown below,
\fBRest\fP() is called in \fIblap\fP whenever \fIblap\fP
notices that \fIbloop\fP is playing a rest.
.so ex/ex22
.LP
To understand the action of
.DS 
.ft C
	if (\fBResting\fP(\fBInstances\fP(bloop))),
.ft R 
.DE
note that the return value from \fBInstances\fP() is a pointer to
the first Player instance on a linked list of instances of this
class.  Since in this example there is only one instance of that class,
we can use \fBInstances\fP() to return a pointer to it.
.LP
\fBRest\fP() effects a one-shot rest.
It is possible to always suppress cmusic output for a Player by calling
\fBSilent\fP().  For instance, \fBSilent\fP(\fBSelf\fP); turns a Player's
own cmusic output off, and with \fBInstance\fP(), one can turn another's
output off as well.  The routine \fBUnsilent\fP() does the inverse.
There is also an \fBUnrest\fP() routine to effect printing even when
\fBRest\fP() has been called, or an \fHr\fP expression is encountered in
a \fBPitch\fP-format cyclic list.
.LP
To get rid of note-list output altogether, do this:
.DS
.ft C
\fBM_start\fP()
{
	\fBPrint_notes\fP = NULL;
}
.ft R
.DE
.LP
\fBPrint_notes\fP is a pointer to a subroutine.  Ordinarily, it is set to
the value of the macro \fBCMUSOUT\fP at the beginning
of Player execution.  The value of the \fBCMUSOUT\fP macro is set by default
to the subroutine \fBcmusout\fP.  When a Player finishes executing,
if \fBPrint_notes\fP is not \fCNULL\fP, the subroutine it points to is called.
In the case of \fBcmusout\fP, the Player's P fields are formatted as a cmusic-style
note statement.
.LP
One can customize or eliminate the normal output from a Player this way.
In the realtime verison, note-list output is normally defeated by default.
.NH
Staccatto and legato
.LP
In all examples so far, with the exception of rests, each note of a Player
followed exactly on the completion of the previous one.  It is often
desirable to have overlaps for legato, or ``underlaps'' for staccato, without
affecting the basic pulse.  
In Player \fIblah\fP, an overlap duration is calculated as a fraction of the
total duration.  Each note lasts .01 times longer than the begin time
of the next note, causing an overlap which varies with the size of the
duration.  This is generally not as useful as having a constant overlap,
which is provided in Player \fIblot\fP.  Staccato is provided in Player 
\fIblonk\fP.
.so ex/ex23
.LP
.LP
Note the use of initialized variables in the above examples for
the variables named \fCoverlap\fP in each Player.
Each time any Player runs this variable will be initialized.
If any Player modifies its value, the modification will be 
discarded as soon as the Player returns.
.NH
Reading scores
.LP
The Player run-time environment has a special usage of the
standard input.  If the startup routines in the Player run-time
library detect that the standard input is a file or pipe, a
built-in Player is invoked to read it.  This Player expects
to read cmusic-style note statements on the standard input.  Upon
reading each note statement, it instantiates a Player named in
\fBP3\fP of the note statement, and sets its begin time and duration
from the note statement as well.  
.LP
The entirety of the note statement is sent to the newly instantiated
Player instance in a different set of \fBP\fP-variables than we have
mentioned so far, the \fBPi\fIn\fR variables.  Each \fBPi\fP variable
contains the character string of the corresponding P-field from the
instantiating note statement.
.LP
This facility makes it possible for Player programs not only to
generate note-statements, but to be driven by them as well.
Here is an example.
.so ex/ex24
.LP
This Player is declared without arguments, which you will recall
simply declares the Player's name, and defines it, and does no
instantiation.  We will rely on the built-in Player reading the
standard input to do this.  This Player simply copies
string parameters from the \fBPi\fP variables to the \fBPs\fP
variables.  It does not call \fBWait_until\fP() because it only
wants to print one note statement for each one received.
.LP
The routine \fBKill\fP() terminates the Player instance supplied
as argument, so each Player instance of this class will only 
print one note statement.  The difference between \fBStop\fP() and
\fBKill\fP() is that a stopped Player can be resumed with a
routine named \fBStart\fP(), whereas a \fBKill\fPed Player vanishes,
and can never be resumed.
.LP
If, for instance we had a file, ``xyzzynotes'', with this in it:
.DS
note 0 xyzzy 10 hi there everybody;
.DE
and said
.DS
% a.out < xyzzynotes
.DE
we would get
.DS
note 0 xyzzy 10 hi there everybody;
.DE
on the standard output.
.LP
This Player could be expanded easily so
that when called, it played a phrase instead of just a note, or
did some other compound action.  Likewise, one could use this capability
to edit existing scores in ways that go beyond simple text editing.
.NH
Dynamic Tempo
.LP
\fIAccelerando\fP and \fIritardando\fP take a little work
to implement, as to do them right requires integration.
.LP
The \fIget_tempo\fP() procedure is an example of how to do arbitrary tempo
changes.  (This routine is provided in the Player runtime library
under the name \fBTempo\fP()).
The subroutine takes as arguments a \fBFunction\fP created by
a \fIgen(1carl)\fP program, start time,
duration and granularity, and returns the tempo-factored duration scaled by
the \fBFunction\fP.  The action of \fCget_tempo\fP() is to integrate that
part of the \fBFunction\fP bounded by the start time and duration to the actual
time in question.  The \fCtempofun\fP variable points to a step function,
created by a statement such as
.DS
.ft C
tempo = \fBGen\fP("step \-L20 0 .5 4 1 20 1");
.ft R
.DE
\fIstep\fP is a \fIgen\fP program that creates step functions.
We will use the resulting tempo function to specify a sequence of tempo
factors, i.e., coefficients to scale the normal durations by in order
to achieve the desired tempo.
Our function says that
the tempo factor at time 0 is .5 (which means that the 
tempo at this point is double-time), the
tempo factor is 1 at time 4, and remains so out to 20
seconds.  Variables \fIabstart\fP and \fIabsdur\fP keep the 
un-tempo-factored times.  The
variable  \fClimit\fP  is the \fIlimit of integration\fP, 
i.e., the granularity of time quanta,
which for this example is set at 1 second.  Time divisions that
fall within this limit are uniformly tempo-factored by linear
interpolation.  Note that the \fIaddress\fP of \fCabstart\fP is
required.  This is so that \fIget_tempo\fP()
can manage that variable for you.
.LP
Note also that variables are declared globally, and are therefor
available to all Players (and routines) following.  Since this example
synchronizes two Players, we have the critical tempo variables global so
they can both get to them.
.so ex/ex25
.LP
.LP
If one substitutes a smoothed function, such as produced by \fIgen4\fP(1CARL),
a more subtle control of incremental tempo change will result.
.SH
Admonitions
.LP
While Player makes some things easier, there are some ways in which
it also gives you enough rope to hang yourself.
The language extensions represented by Player
are not without their pitfalls.  The most notorious of the ones that
are currently known are noted here.
.LP
Avoid naming variables that resemble \fBP\fP-variables.
.LP
Don't hand anything but \fBPitch\fP-format cyclic lists to \fBPitches\fP();
likewise nothing but \fBRhythm\fP-format cyclic lists to \fBRhythms\fP().
.LP
The use of \fBRel_time\fP() depends on your having an explicit 
duration set in the Player declaration.  If you do not, the duration is
set to infinity, causing \fBRel_time\fP() 
to give you the relative time of the
current moment based on how long it will be until the universe ends,
i.e., it will be 0.
.LP
The \fBP\fIn\fR variable set is initialized to 0,  
and \fBPp\fP and \fBPs\fP variable sets are initialized
to \fCNULL\fP.  
However, remember that any \fIauto\fP variables you create yourself
inside a Player are \fInot\fP initialized automatically, 
and in fact are guaranteed by the C compiler to contain
100% pure garbage.  To keep the value of a variable around
from one Player call to another requires that the variable be declared
\fBInstance\fP.   All \fBInstance\fP variables are initialized to 0.
.LP
If you are using more than one \fBPitches\fP() statement in a single Player,
rests in \fBPitches\fP() calls are ``or'ed'' together, that is, any rest
in any \fBPitches\fP() call within a Player causes a rest to occur.
.LP
Make sure that all parentheses, brackets and braces are ballanced!
It might seem to be obvious to say that the C compiler will throw up
if they are not, but besides that,
the .c file that Player
creates may get very strange looking and
you may get very confusing error messages from the compiler if
they are not perfectly ballanced.
.LP
All rules of typecasting in C are observed in Player.
In general, C does the right thing except where passing arguments
to subroutines.
For instance, this is wrong:
.DS
.ft C
\fBP4\fP = frand(1, 3);
.ft R
.DE
and will give strange results, whereas
.DS
P4 = frand(1., 3.);
.DE
will get you what you want.
However, in all circumstances other than procedure calls, C
generally does the right thing about type coercion, e.g., in 
relational operations, arithmetic and assignment statements.
.LP
It is unwise to name any variables with similar names to Player's reserved
words.
.LP
Don't forget where commas are optional and where they are required.
Commas must appear in all the places that C
calls for them, such
as in procedure calls where there is more than one argument, or in
\fCfor\fP
statements with more than one expression per part.
Commas are optional in cyclic lists only.
.LP
.SH
References
.[
$LIST$
.]
.LP
.SH
Scores
.LP
Below are reproduced the scores that result from the execution of the
numbered programs in the text.
.SH
Program Example 1
.LP
.nf
.so exout/ex1.out
.SH
Program Example 2
.LP
.nf
.so exout/ex2.out
.SH
Program Example 3
.LP
.nf
.so exout/ex3.out
.SH
Program Example 4
.LP
.nf
.so exout/ex4.out
.SH
Program Example 5
.LP
.nf
.so exout/ex5.out
.SH
Program Example 6
.LP
.nf
.so exout/ex6.out
.SH
Program Example 7
.LP
.nf
.so exout/ex7.out
.SH
Program Example 8
.LP
.nf
.so exout/ex8.out
.SH
Program Example 9
.LP
.nf
.so exout/ex9.out
.SH
Program Example 10
.LP
.nf
.so exout/ex10.out
.SH
Program Example 11
.LP
.nf
.so exout/ex11.out
.SH
Program Example 12
.LP
.nf
.so exout/ex12.out
.SH
Program Example 13
.LP
.nf
.so exout/ex13.out
.SH
Program Example 14
.LP
.nf
.so exout/ex14.out
.SH
Program Example 15
.LP
.nf
.so exout/ex15.out
.SH
Program Example 16
.LP
.nf
.so exout/ex16.out
.SH
Program Example 17
.LP
.nf
.so exout/ex17.out
.SH
Program Example 18
.LP
.nf
.so exout/ex18.out
.SH
Program Example 19
.LP
.nf
.so exout/ex19.out
.SH
Program Example 20
.LP
.nf
.so exout/ex20.out
.SH
Program Example 21
.LP
.nf
.so exout/ex21.out
.SH
Program Example 22
.LP
.nf
.so exout/ex22.out
.SH
Program Example 23
.LP
.nf
.so exout/ex23.out
.SH
Program Example 24
.LP
.nf
.so exout/ex24.out
.SH
Program Example 25
.LP
.nf
.so exout/ex25.out
